# Бинарный поиск

В [лекции 6](https://youtu.be/YENpZexHfuk) введены два понятия: левый бинарный поиск и правый бинарный поиск. Такое разделение условно и сделано для упрощения понимания и реализации алгоритма бинарного поиска общего вида.

Основная идея: пусть задана монотонная функция, определённая над некоторой последовательностью, тогда левым бинарным поиском будем называть поиск первого подходящего значения функции, а правым бинарным поиском будет называть поиск последнего подходящего значения.
Чаще всего используется функция, возвращающая bool: для левого бинарного поиска нестрого возрастающая, для правого - нестрого убывающая.

Пример. Пусть даны значения функции, возвращающей bool, на некоторой последовательности:

0 0 0 0 0 0 **<ins>1</ins>** 1 1 1 - искомый элемент в левом бинарном поиске <br>
**<ins>1</ins>** 1 1 1 1 1 1 1 1 1 - искомый элемент в левом бинарном поиске <br>
0 0 0 0 0 0 0 0 0 **<ins>0</ins>** - искомый элемент в левом бинарном поиске


1 1 1 1 1 **<ins>1</ins>** 0 0 0 0 - искомый элемент в правом бинарном поиске <br>
1 1 1 1 1 1 1 1 1 **<ins>1</ins>** - искомый элемент в правом бинарном поиске  <br>
**<ins>0</ins>** 0 0 0 0 0 0 0 0 0 - искомый элемент в правом бинарном поиске           

    

Основной алгоритм решения задач контеста:
- понять, к какому типу бинарного поиска проще привести задачу
- написать функцию проверки, принимающую элемент последовательности (и некоторые параметры) и возвращающую bool
- определить граничные значения последовательности, на которой задана функция

#### Код левого бинарного поиска (python):
```python
def lbinsearch(l, r, check, checkparams):
    while l < r:
      m = (l + r) // 2
      if check(m, checkparams):
        r = m
      else:
        l = m + 1
    return l

```

#### Код правого бинарного поиска (python):
```python
def rbinsearch(l, r, check, checkparams):
    while l < r:
      m = (l + r + 1) // 2
      if check(m, checkparams):
        l = m
      else:
        r = m - 1
    return l

```
