#include <iostream>
#include <cstdint>
#include <vector>
#include <algorithm>
#include <unordered_map>

using namespace std;

/*
    основная идея: сохранить в словарь все пары "карточка" - "количество вхождений карточки" 
    далее по отсортированным ключам словаря найти методом двух указателей все такие отрезки отсортированной последовательности ключей, 
    правая граница которых не подходит под условие left * k <= right
    т.е. для каждой левой границы найти правую границу - первую карточку, которая не подходит под условия задачи с коэффциентом k

    далее - комбинаторика, рассмотрим последовательность ключей:
    1 2 3 4 5 6 7 100 200 - keys, k = 10
    допустим, все карточки уникальны (dict[key] = 1 для любого key)
    при первом проходе получим *left = 1, *rigth = 100, между left и rigth находится m чисел = rigth - left - 1 = 6 в примере
    нужно найти количество способов выбрать три карточки
    при проходе методом двух указаталей будем для каждого левого указателя фиксировать карточку под этим указаталем, она обязательно должна входить в комбинацию, а остальные две выбирать
    тогда при полном переборе левого указателя от 0 до количества ключей - 1 получим все искомые комбинации 
    для фиксированной первой карточке есть m способов выбрать вторую карточку и (m - 1) способ выбрать третью карточку 
    получаем m * (m - 1) вариантов
    в примере: фиксируем левую границу *left = 1 на первой позиции из трёх, тогда:
    1 2 -> 3 4 5 6 7 -> 123, 124, 125, 126, 127
      3 -> 2 4 5 6 7 -> 132, 134, 135, 136, 137
      4 -> 2 3 5 6 7 -> 142, 143, 145, 146, 147
      5 -> 2 3 4 6 7 -> 152, 153, 154, 156, 157
      6 -> 2 3 4 5 7 -> 162, 163, 164, 165, 167
      7 -> 2 3 4 5 6 -> 172, 173, 174, 175, 176

    m * (m - 1) = 20 вариантов, если первая карточка на первом месте, столько же - если на втором и третьем
    в итоге такой отрезок даст 3 * m * (m - 1) вариантов

    что делать, если некоторые карточки повторяются?
    рассмотрим варианты:

    1 2 3 4 5 6 7 100 200 - keys, k = 10
    1 2 2 1 1 1 1 1   1   - values
    добавятся комбинации 122, 212, 221, 133, 313, 331 
    т.е. добавятся 3 * (количество value == 2)

    1 2 3 4 5 6 7 100 200 - keys, k = 10
    2 1 1 1 1 1 1 1   1   - values
    добавятся комбинации 112, 121, 211, 113, 131, 311, 114, 141, 411, 115, 151, 511, 116, 161, 611, 117, 171, 711
    т.е. добавятся 3 * m вариантов 

    1 2 3 4 5 6 7 100 200 - keys, k = 10
    3 1 1 1 1 1 1 1   1   - values
    добавится 111
    т.е. добавятся 3

    1 2 3 4 5 6 7 100 200 - keys, k = 10
    1 3 1 3 1 1 1 1   1   - values
    добавится 222, 444
    т.е. добавятся 3 * (количество value == 3)

    любое повторение value даёт 3 варианта,
    но при этом нужно не посчитать повторения два раза при проходе всей последовательности. для этого можно отдельно обрабатывать случай, когда value под левым указателем отлично от 1
*/

int main() {
    int64_t n, k;
    cin >> n >> k;
    unordered_map<int64_t, int64_t> cardsToQuantity;

    for (int64_t i = 0; i < n; ++i) {
        int64_t card;
        cin >> card;
        ++cardsToQuantity[card];
    }

    vector<int64_t> uniqueNums;
    for (auto& [key, value] : cardsToQuantity) {
        uniqueNums.push_back(key);
    }
    sort(uniqueNums.begin(), uniqueNums.end());

    int64_t duplicatesQuantity = 0;
    int64_t count = 0;
    size_t right = 0;

    for (size_t left = 0; left < uniqueNums.size(); ++left) {
        while (right < uniqueNums.size() && k * uniqueNums[left] >= uniqueNums[right]) { //останавливаемся на первом неподходящем элементе
            if(cardsToQuantity[uniqueNums[right]] > 1) {
                ++duplicatesQuantity;
            }
            ++right;
        }
        size_t rangeLength = right - left - 1;
        if (cardsToQuantity[uniqueNums[left]] > 1) {
            count += 3 * (rangeLength);
        }
        if (cardsToQuantity[uniqueNums[left]] > 2) {
            count += 1;
        }
        count += 3 * (rangeLength) * (rangeLength - 1);
        if (cardsToQuantity[uniqueNums[left]] > 1) {
            --duplicatesQuantity;
        }
        count += duplicatesQuantity * 3;
    }

    cout << count << '\n';

    return 0;
}